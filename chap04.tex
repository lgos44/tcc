\chapter{Implementação}
A implementação dos algoritmos de controle detalhados nos capítulos anteriores for feita como extensão ao software RobotGUI desenvolvido pela equipe do LEAD-GSCAR, idealizado por Alex F. Neves Msc. 

%\section{Motivação} 
%Modular, genérico, ...

\section{Ferramentas}
Os seguintes softwares e \textit{frameworks} foram utilizados:

\begin{itemize}
\item Linux (Ubuntu) como Sistema Operacional
\item C++ como linguagem de programação
\item ROS como \textit{framework} principal utilizado o RobotGUI, fornecendo comunicação entre nós através de mensagens e serviços. Será descrito mais detalhadamente na próxima seção.
\item Qt como \textit{framework} para elaboração da interface gráfica. 
\end{itemize}

\section{ROS}

\section{Conceitos}

Primeiramente define-se como Computador Base aquele que será utilizado pelo operador para controlar e visualizar dados do robô. Define-se Computador Embarcado, ou do Robô aquele que está no robô conectado a todos os equipamentos, sensores e atuadores. O software executa módulos diferentes no robô e na base.

A arquitetura do RobotGUI baseia-se nos seguintes conceitos principais:

\begin{itemize}
\item \textbf{Components}: Lidam com a comunicação e processam dados no Computador Base. São essencialmente \textit{Nodelets} de ROS, podendo utilizar funcionalidades como comunicação através de mensagens e serviços, utilizar parametros e bibliotecas de ROS. Permitem maior modularidade pois comonentes podem ser inicializados independentemente do \textit{RobotGUI}.

\item \textbf{Tools:} São elementos gráficos da interface para o usuário. São utilizadas para interagir com o robô e visualizar informação. São criadas como \textit{plugins} para o ROS \textit{pluginlib} e independetes de qualquer biblioteca do ROS.

\item \textbf{Interação entre Compontents e Tools:} Tools e Components podem se conectar, quando isso ocorre eles interagem entre si a nível de "ponteiro para objeto". Essa conecção permite que o desenvolvimento da interface através do \textit{Qt} seja quase que independente do desenvolvimento do código que lida com hardware, lógica e comunicação.

\item \textbf{RobotGUI}
\end{itemize}


\section{Modos de Controle}

\subsection{Velocidade no Espaço Operacional}
\subsubsection{Base}
\subsubsection{Efetuador}
\subsection{Posição no Espaço das Juntas}
\subsection{Posição no Espaço Operacional}
\subsection{Rastreamento de Trajetória}
\subsection{Servo Visão}
\subsection{Força}
\subsubsection{Float}
\subsubsection{Approach}
Considera-se o problema de controle de força na direção de approach para o manipulador robótico 4-DOF em questão. A realimentação de força é feita com o uso do sensor descrito em \ref{sec:sensor_forca}. O objetivo de controle é rastrear uma entrada na forma de um degrau de força, a ser aplicada em uma placa de poliestireno montada em um suporte fixado na verical como mostra a figura \ref{fig:suporte_forca}.  

É possível modelar o ambiente (força de contato), ou seja, a placa de poliestireno como uma mola linear, através da \textit{Lei de Hook}: \cite{bib:toni}
\begin{equation}
f = -k_s (x - x_s)
\end{equation}
onde $x$ é o ponto de contato com a superfície e $x_s$
\subsubsection{Híbrido}
\subsection{Master-Slave (Omni)}